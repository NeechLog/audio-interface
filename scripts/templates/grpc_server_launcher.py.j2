"""
Audio Interface gRPC Server Launcher Library

Provides a configurable gRPC server launcher that supports:
- Multiple processes and threads configuration
- Graceful shutdown handling
- Logging configuration
- Easy integration for audio transcription and cloning services
"""

import logging
import signal
import sys
import multiprocessing
from concurrent import futures
from typing import Optional, Dict, Any, Callable
import grpc
from pathlib import Path


class GrpcServerConfig:
    """Configuration for gRPC server."""
    
    def __init__(
        self,
        host: str = "0.0.0.0",
        port: int = 50051,
        max_workers: int = 10,
        num_processes: int = 1,
        log_level: str = "INFO",
        log_file: str = "grpc_server.log",
        log_format: str = "%(asctime)s - %(name)s - %(levelname)s - %(message)s",
        graceful_shutdown_timeout: int = 30,
        max_message_length: int = 4 * 1024 * 1024,  # 4MB default for audio
        daemon: bool = False,
        pid_file: Optional[str] = "server.pid",
        working_dir: str = "/",
        umask: int = 0o022,
        uid: Optional[int] = None,
        gid: Optional[int] = None,
        options: Optional[Dict[str, Any]] = None
    ):
        self.host = host
        self.port = port
        self.max_workers = max_workers
        self.num_processes = num_processes
        self.log_level = log_level
        self.log_file = log_file
        self.log_format = log_format
        self.graceful_shutdown_timeout = graceful_shutdown_timeout
        self.max_message_length = max_message_length
        self.daemon = daemon
        self.pid_file = pid_file
        self.working_dir = working_dir
        self.umask = umask
        self.uid = uid
        self.gid = gid
        self.options = options or {}
        
        # Default gRPC options for audio processing
        self.grpc_options = {
            'grpc.max_send_message_length': max_message_length,
            'grpc.max_receive_message_length': max_message_length,
            'grpc.keepalive_time_ms': 30000,
            'grpc.keepalive_timeout_ms': 5000,
            'grpc.keepalive_permit_without_calls': True,
            'grpc.http2.max_pings_without_data': 0,
            'grpc.http2.min_time_between_pings_ms': 10000,
            'grpc.http2.min_ping_interval_without_data_ms': 300000,
            **self.options
        }

    def setup_logging(self):
        """Setup logging configuration."""
        # Check if we are in daemon mode to adjust logging
        handlers = [logging.FileHandler(self.log_file)]
        
        # Only add stdout handler if not a daemon
        if not self.daemon:
            handlers.append(logging.StreamHandler(sys.stdout))
            
        logging.basicConfig(
            level=getattr(logging, self.log_level.upper()),
            format=self.log_format,
            handlers=handlers,
            force=True  # Force reconfiguration
        )


class GrpcServerLauncher:
    """Configurable gRPC server launcher for audio processing services."""
    
    def __init__(self, config: GrpcServerConfig):
        self.config = config
        self.server = None
        self.logger = logging.getLogger(__name__)
        # Initial logging setup (will be re-run if daemonized)
        self.config.setup_logging()
        
    def create_server(self, service_add_func: Callable, service_instance: Any) -> grpc.Server:
        """Create gRPC server with the specified service."""
        # Create thread pool executor
        thread_pool = futures.ThreadPoolExecutor(max_workers=self.config.max_workers)
        
        # Create server with thread pool
        server = grpc.server(thread_pool, options=self.config.grpc_options.items())
        
        # Add service to server
        service_add_func(service_instance, server)
        
        return server
    
    def start_server(self, service_add_func: Callable, service_instance: Any) -> None:
        """Start the gRPC server with proper signal handling and optional daemonization."""
        if self.config.daemon:
            self._run_as_daemon(self._run_server_core, service_add_func, service_instance)
        else:
            self._run_server_core(service_add_func, service_instance)

    def _run_as_daemon(self, target_func: Callable, *args, **kwargs):
        """Run the given target function in a daemon context."""
        try:
            import daemon
            from daemon import pidfile
        except ImportError:
            self.logger.error("python-daemon is required for daemon mode. Install it with: pip install python-daemon")
            sys.exit(1)
            
        context_kwargs = {
            'working_directory': self.config.working_dir,
            'umask': self.config.umask,
            'detach_process': True,
        }
        
        if self.config.pid_file:
            # Ensure pid_file path is absolute because daemon context changes working directory
            abs_pid_file = os.path.abspath(self.config.pid_file)
            context_kwargs['pidfile'] = pidfile.TimeoutPIDLockFile(abs_pid_file)
        
        if self.config.uid is not None:
            context_kwargs['uid'] = self.config.uid
        if self.config.gid is not None:
            context_kwargs['gid'] = self.config.gid

        # Preserve file handles if needed, but we re-setup logging inside
        
        self.logger.info("Starting server in daemon mode...")
        
        try:
            with daemon.DaemonContext(**context_kwargs):
                # Re-setup logging in the daemon process
                self.config.setup_logging()
                self.logger.info("Daemon started successfully")
                target_func(*args, **kwargs)
        except Exception as e:
            # We can't log here effectively if daemon setup failed, but try anyway
            self.logger.error(f"Failed to start daemon: {e}")
            raise

    def _run_server_core(self, service_add_func: Callable, service_instance: Any) -> None:
        """Core server execution logic."""
        # Create server
        self.server = self.create_server(service_add_func, service_instance)
        
        # Add port
        address = f'{self.config.host}:{self.config.port}'
        self.server.add_insecure_port(address)
        
        # Setup signal handlers for graceful shutdown
        self._setup_signal_handlers()
        
        try:
            self.logger.info(f"Starting gRPC server on {address}")
            self.logger.info(f"Configuration: {self.config.num_processes} processes, {self.config.max_workers} threads per process")
            self.logger.info(f"Max message size: {self.config.max_message_length / (1024*1024):.1f}MB")
            
            self.server.start()
            self.logger.info("gRPC server started successfully")
            
            # Wait for termination
            self.server.wait_for_termination()
            
        except KeyboardInterrupt:
            self.logger.info("Received keyboard interrupt, shutting down...")
            self._graceful_shutdown()
        except Exception as e:
            self.logger.error(f"Server error: {e}")
            self._graceful_shutdown()
            raise
    
    def _setup_signal_handlers(self):
        """Setup signal handlers for graceful shutdown."""
        def signal_handler(signum, frame):
            self.logger.info(f"Received signal {signum}, shutting down...")
            self._graceful_shutdown()
            
        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)
    
    def _graceful_shutdown(self):
        """Perform graceful shutdown of the server."""
        if self.server:
            self.logger.info("Initiating graceful shutdown...")
            
            # Graceful shutdown with timeout
            self.server.stop(self.config.graceful_shutdown_timeout)
            self.logger.info("Server shutdown complete")
    
    @classmethod
    def create_multi_process_server(
        cls, 
        config: GrpcServerConfig, 
        service_add_func: Callable, 
        service_class: Any,
        service_init_args: tuple = (),
        service_init_kwargs: dict = None
    ):
        """Create multi-process gRPC server."""
        
        def run_logic():
            if config.num_processes <= 1:
                # Single process mode
                launcher = cls(config)
                service_instance = service_class(*service_init_args, **(service_init_kwargs or {}))
                launcher._run_server_core(service_add_func, service_instance)
            else:
                # Multi-process mode
                processes = []
                
                def worker_process():
                    """Worker process function."""
                    # Disable daemon flag for workers since they are already inside a daemon (or main process)
                    # and we don't want them to try to double-daemonize
                    worker_config = config
                    worker_config.daemon = False 
                    
                    launcher = cls(worker_config)
                    service_instance = service_class(*service_init_args, **(service_init_kwargs or {}))
                    launcher._run_server_core(service_add_func, service_instance)
                
                # Start worker processes
                for i in range(config.num_processes):
                    process = multiprocessing.Process(target=worker_process)
                    process.start()
                    processes.append(process)
                    # config.setup_logging()  # Setup logging for each process
                    logging.info(f"Started worker process {i+1}/{config.num_processes}")
                
                # Wait for all processes
                try:
                    for process in processes:
                        process.join()
                except KeyboardInterrupt:
                    logging.info("Received keyboard interrupt, terminating processes...")
                    for process in processes:
                        process.terminate()
                    for process in processes:
                        process.join()

        # Handle daemonization at the top level
        if config.daemon:
            launcher = cls(config) # Temporary instance just to call _run_as_daemon
            launcher._run_as_daemon(run_logic)
        else:
            run_logic()


def create_default_config(
    port: int = 50051,
    max_workers: int = 10,
    num_processes: int = 1,
    log_level: str = "INFO",
    log_file: str = "grpc_server.log",
    max_message_length_mb: int = 4,
    daemon: bool = False,
    pid_file: Optional[str] = "server.pid"
) -> GrpcServerConfig:
    """Create default configuration for audio processing servers."""
    return GrpcServerConfig(
        port=port,
        max_workers=max_workers,
        num_processes=num_processes,
        log_level=log_level,
        log_file=log_file,
        max_message_length=max_message_length_mb * 1024 * 1024,
        daemon=daemon,
        pid_file=pid_file
    )


# Convenience function for easy server startup
def start_grpc_server(
    service_add_func: Callable,
    service_class: Any,
    port: int = 50051,
    max_workers: int = 10,
    num_processes: int = 1,
    log_level: str = "INFO",
    log_file: str = "grpc_server.log",
    max_message_length_mb: int = 4,
    daemon: bool = False,
    pid_file: Optional[str] = "{{ package_name.lower() }}.pid",
    service_init_args: tuple = (),
    service_init_kwargs: dict = None
):
    """
    Convenience function to start gRPC server with common configuration.
    
    Args:
        service_add_func: Function to add service to server (e.g., TranscribeWorker_pb2_grpc.add_TranscribeWorkerServicer_to_server)
        service_class: Service implementation class
        port: Port to listen on
        max_workers: Number of worker threads per process
        num_processes: Number of processes to spawn
        log_level: Logging level
        log_file: Path to log file
        max_message_length_mb: Maximum message length in MB
        daemon: Run as daemon in background
        pid_file: Path to PID file for daemon
        service_init_args: Arguments to pass to service class constructor
        service_init_kwargs: Keyword arguments to pass to service class constructor
    """
    config = create_default_config(
        port=port,
        max_workers=max_workers,
        num_processes=num_processes,
        log_level=log_level,
        log_file=log_file,
        max_message_length_mb=max_message_length_mb,
        daemon=daemon,
        pid_file=pid_file
    )
    
    launcher = GrpcServerLauncher(config)
    
    if num_processes > 1:
        launcher.create_multi_process_server(
            config, service_add_func, service_class, 
            service_init_args, service_init_kwargs
        )
    else:
        if daemon:
            launcher.start_server(service_add_func, service_class(*service_init_args, **(service_init_kwargs or {})))
        else:
            service_instance = service_class(*service_init_args, **(service_init_kwargs or {}))
            launcher.start_server(service_add_func, service_instance)
